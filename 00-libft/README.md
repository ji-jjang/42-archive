# libft
> 이 프로젝트의 목적은 흔히 쓰이는 함수들을 재구성하여 이후의 모든 프로젝트에서 사용될 C 라이브러리를 제작하는 것입니다.

# Feedback
## 1. 일관된 예외처리하기 
- null 처리 일관되게!

## 2. 필요한 함수만 include하기
- 모든 파일에 "libft.h"를 선언하는 건 효율적이지 않다.

## 3. Makefile re 옵션은 병렬로 실행하지 말기
```Makefile
re: fclean all
```
- fclean과 all이 병렬적으로 실행되기 때문에 오류날 가능성이 있다. 안전하게 직렬로 바꿔주어야 한다. (-j 옵션을 사용할 경우)

## 4. ft_memchr
```c
return ((void *)&p[idx]);
```
- p[idx]라는 값에 접근하고 그 주소에 다시 접근하는 것보다 (p + idx)로 한번에 주소에 접근하는 게 효율적이다.

## 5. ft_strnstr
```c
while (*haystack && ++cnt <= len - ft_strlen(needle))
```
- 반복문을 돌 때마다 ft_strlen함수를 호출하는 것은 비효율적이다.

## 6. ft_strjoin
```c
ft_strcat(copy, s1);
ft_strcat(copy, s2);
```
- 이어붙일 때 처음부터 찾는 건 비효율적이다. s1의 길이만큼 당겨주도록 하자.

## 7. ft_lstadd_back
- 마지막 노드를 찾을 때 이미 구현된 함수(ft_lstlast)를 사용하자.

## 8. ft_strtrim
- set이 담고 있는 문자를 1로 초기화한다. 모든 문자를 순회하는 것이 아닌(s1) map에 담긴 문자만 순회하면서 속도를 올릴 수 있다.

# 생각해보기

## 1. 왜 ar 명령어를 사용하여 라이브러리를 생성하여야 하고 libtool 명령어는 사용이 금지되었는가?
- `ar`은 유닉스의 초창기부터 사용되었다고 한다. `libtool`은 동적 및 정적 라이브러리 모두 지원하는 GNU 도구이며 ar을 능가하는 훨씬 많은 기능을 가지고 있다고 한다.
- 단순히 정적 라이브러리를 위한 과제이므로 `ar`사용을 강제하는 것으로 보인다.

## 2. 왜 size_t 자료형을 사용할까? (unsigned int와 차이점)
- 시스템에서 어떤 객체나 값이 포함할 수 있는 최대 크기의 데이터를 표현하는 타입이다. 크기에 음수는 필요 없기에 unsigned형으로 나타낸다.
- `size_t`의 경우 32비트 운영체제에서는 부호 없는 32비트 정수(unsigned int), 64비트 운영체제에서는 부호 없는 64비트 정수(unsigned long long)으로 `고정된 크기`를 가진다. 하지만 `unsigned int`는 `운영체제마다 크기가 다르다`.

## 3. const 위치에 따른 차이는 무엇인가?
### 1. 자료형 앞에 const가 오는 경우
- 포인터 변수 앞에 const가 오는 경우도 해당한다. ex) char **ft_split(char const *s, char c)
- 변수에 저장된 값의 변경을 허용하지 않는다.
```c
const double PI = 3.14;
PI = 3.141592; // error

int num1 = 42;
int num2 = 21;
const int *ptr = &num1;
ptr = &num2; // possible
*ptr = num2; // error
```
### 2. 변수 앞에 const가 오는 경우
- 변수 주소를 변경하는 것을 허용하지 않는다.
```c
int num1 = 42;
int num2 = 21;
int *const ptr = &num1;
*ptr = num2; // possible
ptr = &num2; // error
```
> 3. 둘 다 const가 오는 경우
- 값과 주소의 변경을 허용하지 않는다.
```c
int num1 = 42;
int num2 = 21;
const int *const ptr = &num1;
*ptr = num2; // error
ptr = &num2; // error
```
##  4. 정적(static) 변수의 특징은 무엇인가?
- `데이터영역`에 저장된다. 데이터 영역은 `프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸`한다.
- `자신이 선언된 소스 파일 안에서만 사용`할 수 있고, 외부에서는 가져다 쓸 수 없다.
- 선언과 동시에 0으로 초기화된다.
- 매개변수로 사용할 수 없다.

##  5. 메모리 관련 함수는 왜 unsigned char로 쓰는가?
- 컴퓨터의 정보 처리 단위는 1byte가 효율적이고, 메모리가 공간을 의미하고 공간에서 음수는 필요하지 않기에 unsigned char 로 계산한다.

## 6. 메모리 관련 함수와 문자열 함수 차이(memcpy, strcpy 등)
- 문자열의 끝은 NULL인 것에 반해, 메모리 영역은 NULL도 유효한 공간으로 보기 때문에 크기 n을 명시적으로 지정해주어야 한다.

## 7. memset 동작방식
- memset은 1byte단위로 초기화를 한다. 1byte가 아닌 자료형에 대해선 0 과 -1 이외의 값으로 초기화하면 예상했던 결과와 다르다.
- 왜 -1은 제대로 작동할까? 2의 보수법을 취하는데 -1 은 바이트를 1로 초기화한다. 11111111 1111111 1111111 1111111은 -1을 나타내므로 제대로 동작하게 된다.
- 그렇다면 1초기화는 어떻게 동작할까?
```c
int arr[1];
memset(arr, 1, sizeof(int) * 1);
printf("%d ", (arr[0]));
```
- 내가 생각한 결과 00000001 00000001 00000001 00000001
- 실제 출력 결과 : 10000000 10000000 10000000 1 (1684309)
- 엔디안 방식(낮은 주소에 데이터의 낮은 바이트(LSB, Least Significant Bit)부터 저장)으로 출력되는 것을 확인할 수 있다. 

## 8. atoi 동작방식
- atoi() 함수는 libc에 의해 stdtol()를 내부로 돌려서 결과값을 리턴하는 방식을 가졌다.
- atoi()의 리턴 타입은 int, strtol()의 리턴 타입은 long 이다.
- strtol()함수에 오버플로우 값이 들어오면 LONG_MAX, 언더플로우 값이 들어오면 LONG_MIN을 리턴한다.
- atoi()함수에 LONG 오버플로우 값이 들어오면 -1, 언더플로우 값이 들어오면 0을 리턴한다.
